<!DOCTYPE html>

<html lang="en">

<head>


    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hex Hyperlane Editor</title>
    <style>
        /* Theme variables */
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --modal-bg: #ffffff;
            --modal-border: #000000;
            --btn-text-color: #000;
            --info-color: #555;
            --button-bg: #f0f0f0;
            /* light‐mode button background */
        }

        body.dark {
            --bg-color: #121212;
            --text-color: #eeeeee;
            --modal-bg: #1e1e1e;
            --modal-border: #555;
            --btn-text-color: #fff;
            --info-color: #eee;
            --button-bg: #2a2a2a;
            /* dark‐mode button background */
        }

        body {
            margin: 0;
            padding-top: 60px;
            font-family: sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        svg {
            background: var(--bg-color);
            border: 1px solid #000;
            /* always black */
        }

        #hexMap {
            width: 95%;
            border: 1px solid #000;
            height: calc(95vh - 60px);
            /* subtract your top bar height */
            max-width: 2000px;
            margin: 10px auto;
            display: block;
            /* removes inline-block whitespace */
        }

        svg text {
            pointer-events: none;
            user-select: none;
        }

        /* Hex styling */
        .hex {
            stroke: #000;
            stroke-width: 1;
            cursor: pointer;
        }

        .hex-overlay {
            font-family: "Segoe UI Symbol", "Noto Emoji";
            font-size: 16px;
            fill: var(--text-color);
        }

        .selected {
            fill: #ff0;
            stroke-width: 4;
        }

        .link-line {
            stroke: blue;
            stroke-width: 2;
            fill: none;
        }

        /* Buttons */
        .mode-button,
        .primary-button {
            color: #000;
            /* always black text */
        }

        body:not(.dark) .mode-button,
        body:not(.dark) .primary-button {
            border: 1px solid #000;
        }

        .mode-button.active {
            outline: 3px solid var(--text-color);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            font-weight: bold;
        }

        .primary-button {
            padding: 10px 16px;
            font-size: 1.05em;
            font-weight: bold;
            background-color: #1fa3ff;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Top bar */
        #topBar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 8px 16px;
            background: var(--bg-color);
            border-bottom: 1px solid var(--modal-border);
            z-index: 100;
            box-sizing: border-box;
        }

        #leftControls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #versionTag {
            position: absolute;
            top: 10px;
            right: 15px;
            background: #444;
            color: white;
            font-size: 0.85em;
            padding: 4px 10px;
            border-radius: 4px;
            font-family: monospace;
            z-index: 200;
        }

        #controlsPanel>div {
            margin-bottom: 8px;
        }

        #controlsPanel button,
        #controlsPanel input,
        #controlsPanel label {
            pointer-events: auto;
        }

        /* ————————————————————————————————————————————————————————————
       1) Restore individual button color overrides
       ———————————————————————————————————————————————————————————— */
        .mode-button {
            background-color: var(--button-bg);
            /* keep existing rules */
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
            color: #000;
            /* black text always */
        }

        /* in dark mode make top‐bar buttons white */
        body.dark #topBar .mode-button {
            background-color: #ffffff;
            /* keep their black text */
            color: #000;
            /* you can also force a border if you like */
            border: 1px solid #000;
        }


        /* specific sector button colors */
        .btn-1 {
            background: #cce5ff;
        }

        .btn-2 {
            background: #49a1ff;
        }

        .btn-3 {
            background: #005cbf;
            color: #fff;
        }

        .btn-legendary {
            background: #b300ff;
            color: #fff;
        }

        .btn-empty {
            background: #fff;
        }

        .btn-special {
            background: #ff83a0;
        }

        .btn-void {
            background: #2b2b2b;
            color: #fff;
        }

        .btn-supernova {
            background: #ffe5b4;
        }

        .btn-nebula {
            background: #e6ccff;
        }

        .btn-asteroid {
            background: #d9d9d9;
        }

        .btn-rift {
            background: #7b7b7b;
            color: #fff;
        }

        .btn-homesystem {
            background: #059f00;
            color: #fff;
        }

        /* ————————————————————————————————————————————————————————————
       2) Main controls panel (never moves)
       ———————————————————————————————————————————————————————————— */
        #controlsPanel {
            position: fixed;
            top: 60px;
            left: 16px;
            background: var(--bg-color);
            padding: 8px;
            border: 1px solid var(--modal-border);
            z-index: 50;
        }

        /* ————————————————————————————————————————————————————————————
       3) Sector buttons (cycles left / top / right)
       ———————————————————————————————————————————————————————————— */
        #sectorControlsContainer {
            position: fixed;
            z-index: 50;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        /* LEFT: vertical */
        .pos-left {
            top: 220px;
            left: 16px;
            flex-direction: column;
            width: 160px;
        }

        /* TOP: two rows */
        .pos-top {
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            flex-direction: row;
            max-width: calc(160px * 4 + 4px);
        }

        /* RIGHT: vertical */
        .pos-right {
            top: 220px;
            right: 16px;
            left: auto;
            flex-direction: column;
            width: 160px;
        }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--modal-bg);
            color: var(--text-color);
            padding: 1em;
            border: 1px solid var(--modal-border);
            z-index: 200;
            max-width: 80%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }

        textarea,
        #exportText,
        #exportTypesText,
        #importText,
        #importTypesText,
        #exportHyperlanePositionsText {
            width: 100%;
            height: 200px;
            background: var(--modal-bg);
            color: var(--text-color);
            border: 1px solid var(--modal-border);
        }

        /* Info text */
        #controls,
        #Info,
        #Info2 {
            color: var(--info-color);
        }
    </style>
</head>

<body>
    <!-- Top Bar -->
    <div id="topBar">
        <div id="leftControls">
            <button onclick="toggleTheme()" class="mode-button">Toggle Dark Mode</button>
            <button onclick="toggleHelp()" class="mode-button">Help</button>
            <button onclick="toggleInfo()" class="mode-button">Import/Export How-To</button>
            <button onclick="toggleFeatures()" class="mode-button">Features</button>
            <button onclick="arrangeControls()" class="mode-button">Arrange Controls</button>
        </div>
        <div id="versionTag">v0.8.5</div>
    </div>

    <!-- Controls Panel -->
    <div id="controlsPanel">
        <button onclick="exportData()">Export HL</button>
        <button onclick="exportSectorTypes()">Export Types</button>
        <button onclick="exportHyperlaneTilePositions()">Export Pos</button>
        <button onclick="showImportModal()">Import HL</button>
        <button onclick="document.getElementById('importTypesModal').style.display='block'">Import Types</button>
        <br><br>
        Rings: <input id="ringCount" type="number" min="1" max="15" value="6" />
        <button onclick="generateMap()" class="primary-button">Generate Map</button>
    </div>

    <div id="sectorControlsContainer" class="pos-left">
        <button onclick="setMode('hyperlane')" class="mode-button btn-empty">Hyperlane</button>
        <button onclick="setMode('1 planet')" class="mode-button btn-1">1 Planet</button>
        <button onclick="setMode('2 planet')" class="mode-button btn-2">2 Planet</button>
        <button onclick="setMode('3 planet')" class="mode-button btn-3">3 Planet</button>
        <button onclick="setMode('legendary planet')" class="mode-button btn-legendary">Legendary Planet</button>
        <button onclick="setMode('empty')" class="mode-button btn-empty">Empty</button>
        <button onclick="setMode('special')" class="mode-button btn-special">Special</button>
        <button onclick="setMode('void')" class="mode-button btn-void">Void</button>
        <button onclick="setMode('supernova')" class="mode-button btn-supernova">Supernova</button>
        <button onclick="setMode('nebula')" class="mode-button btn-nebula">Nebula</button>
        <button onclick="setMode('asteroid')" class="mode-button btn-asteroid">Asteroid</button>
        <button onclick="setMode('rift')" class="mode-button btn-rift">Rift</button>
        <button onclick="setMode('homesystem')" class="mode-button btn-homesystem">Homesystem</button>
    </div>

    <!-- <svg id="hexMap" width="1400" height="1200"></svg> -->
    <!-- remove fixed width/height -->
    <svg id="hexMap" viewBox="0 0 1400 1000" preserveAspectRatio="xMidYMid meet"></svg>


    <div id="exportModal" class="modal">
        <h3>Hyperlane Data</h3>
        <textarea id="exportText"></textarea><br>
        <button onclick="navigator.clipboard.writeText(document.getElementById('exportText').value)">Copy</button>
        <button onclick="closeModal('exportModal')">Close</button>
    </div>
    <div id="importModal" class="modal">
        <h3>Import Hyperlane Data</h3>
        <textarea id="importText"></textarea><br>
        <button onclick="importData()">Import</button>
        <button onclick="closeModal('importModal')">Close</button>
    </div>
    <div id="importTypesModal" class="modal">
        <h3>Import Sector Types</h3>
        <textarea id="importTypesText"></textarea><br>
        <button onclick="importSectorTypes()">Import</button>
        <button onclick="closeModal('importTypesModal')">Close</button>
    </div>
    <div id="exportTypesModal" class="modal">
        <h3>Sector Type Export</h3>
        <textarea id="exportTypesText"></textarea><br>
        <button onclick="navigator.clipboard.writeText(document.getElementById('exportTypesText').value)">Copy</button>
        <button onclick="closeModal('exportTypesModal')">Close</button>
    </div>
    <div id="exportHyperlanePositionsModal" class="modal">
        <h3>Hyperlane Tile Positions</h3>
        <textarea id="exportHyperlanePositionsText"></textarea><br>
        <button
            onclick="navigator.clipboard.writeText(document.getElementById('exportHyperlanePositionsText').value)">Copy</button>
        <button onclick="closeModal('exportHyperlanePositionsModal')">Close</button>
    </div>

    <div id="versionTag">v0.8.9</div>

    <div id="controlsModal" class="modal">
        <h3>Controls</h3>
        <ul style="font-size:0.9em; line-height:1.6;">
            <li>🖱️ <strong>Left-click:</strong> Select hex</li>
            <li>🖱️ <strong>ALT + Left-click:</strong> Remove one hyperlane</li>
            <li>🖱️ <strong>SHIFT + Left-click:</strong> Remove all hyperlanes from hex</li>
            <li>🖱️ <strong>Right-click:</strong> Cancel selection</li>
            <li>🖱️ <strong>Middle-click + drag:</strong> Pan the map</li>
            <li>🔍 <strong>Scroll wheel:</strong> Zoom in/out</li>
            <li>⌨️ <strong>SHIFT + R while hovering:</strong> Clear hex (type + links)</li>
            <li>🌙 <strong>Toggle Dark Mode:</strong> Top-left button</li>
        </ul>
        <button onclick="closeModal('controlsModal')">Close</button>
    </div>
    <div id="infoModal" class="modal">
        <h3>Import/Export How-To</h3>
        <ul style="font-size:0.9em; line-height:1.6;">
            <li><strong>Export Hyperlane:</strong> Copy output to <code>/map custom_hyperlanes</code></li>
            <li><strong>Export Sector Types:</strong> Copy to <code>/map add_tile_list</code></li>
            <li><strong>Export Hyperlane Positions:</strong> Outputs tile list for map position inclusion</li>
            <li><strong>Import Hyperlanes:</strong> Paste from <code>/map custom_hyperlanes</code></li>
            <li><strong>Import Sector Types:</strong> Based on code and tile ID CSV</li>
            <li><strong>Load ID Reference CSV:</strong> Required for proper tile type mapping</li>
        </ul>
        <button onclick="closeModal('infoModal')">Close</button>
    </div>
    <div id="featuresModal" class="modal">
        <h3>Features and Contact</h3>
        <ul style="font-size:0.9em; line-height:1.6;">
            <li><strong>To Do:</strong> Wormholes, full export string, sector finding</li>
            <li><strong>Planned:</strong> UI improvements, directional reach highlighting</li>
            <li><strong>Feedback & Contact:</strong> GitHub Issues or email</li>
        </ul>
        <button onclick="closeModal('featuresModal')">Close</button>
    </div>

    <input type="file" id="idImportCSV" accept=".csv" style="display: none" />
    <button onclick="document.getElementById('idImportCSV').click()">Load ID Reference CSV</button>
    <br />



    <script>
        const svg = document.getElementById('hexMap');
        function showImportModal() {
            document.getElementById('importModal').style.display = 'block';
        }
        const hexRadius = 40;
        const sqrt3 = Math.sqrt(3);
        const hexes = {};
        let drawnSegments = [];
        let selectedPath = [];
        let linking = true;
        let unlinking = false;
        let mode = 'hyperlane';
        let fillCorners = false;
        let hoveredHexLabel = null; // Global variable (add this near top of script)
        let sectorIDLookup = {};         // Maps code → data row
        let originalHexIDs = {};         // Maps hex label → code used during import
        //const positions = ['vertical-left','horizontal-top','vertical-right'];
        //let posIndex = 0;
        const _positions = ['pos-left', 'pos-top', 'pos-right'];
        let _posIndex = 0;

        const sectorColors = {
            '': '#eee',
            '1 planet': '#cce5ff',
            '2 planet': '#49a1ff',
            '3 planet': '#005cbf',
            'legendary planet': '#b300ff',
            'empty': '#ffffff',
            'supernova': '#ffe5b4',
            'rift': '#7b7b7b',
            'nebula': '#e6ccff',
            'asteroid': '#d9d9d9',
            'special': '#ff83a0',
            'homesystem': '#059f00',
            'void': '#2b2b2b'
        };


        // Directions for hyperlane edges (rotated 2 steps CCW)
        const edgeDirections = [
            { q: 0, r: -1 },
            { q: 1, r: -1 },
            { q: 1, r: 0 },
            { q: 0, r: 1 },
            { q: -1, r: 1 },
            { q: -1, r: 0 }
        ];
        // Directions for ring generation (flat-top hex)
        const ringDirections = [
            { q: 1, r: 0 },
            { q: 0, r: 1 },
            { q: -1, r: 1 },
            { q: -1, r: 0 },
            { q: 0, r: -1 },
            { q: 1, r: -1 }
        ];

        const effectIconPositions = [
            { dx: -15, dy: -15 },
            { dx: 15, dy: -15 },
            { dx: -15, dy: 15 },
            { dx: 15, dy: 15 },
            { dx: -25, dy: 25 }
        ];

        function hexToPixel(q, r) {
            return {
                x: hexRadius * 1.5 * q + 500,
                y: hexRadius * sqrt3 * (r + q / 2) + 500
            };
        }

        /*
                function arrangeControls() {
                    const svgEl = document.getElementById('hexMap');
                    const rect = svgEl.getBoundingClientRect();
                    const container = document.getElementById('sectorControlsContainer');
        
                    // ensure we’re absolutely positioned
                    container.style.position = 'absolute';
                    container.style.flexDirection = positions[posIdx] === 'top'
                        ? 'row'           // lay out horizontally when “top”
                        : 'column';       // vertically when “left” or “right”
        
                    switch (positions[posIdx]) {
                        case 'left':
                            container.style.top = `${rect.top + window.scrollY + 160}px`;
                            container.style.left = `${rect.left + window.scrollX - container.offsetWidth + 130}px`;
                            break;
                        case 'top':
                            container.style.left = `${rect.left + window.scrollX + (rect.width - container.offsetWidth) / 2 + 75}px`;
                            container.style.top = `${rect.top + window.scrollY - container.offsetHeight + 130}px`;
                            break;
                        case 'right':
                            container.style.top = `${rect.top + window.scrollY + 160}px`;
                            container.style.left = `${rect.right + window.scrollX - 160}px`;
                            break;
                    }
        
                    // advance to next for next click
                    posIdx = (posIdx + 1) % positions.length;
                }
        */


        function arrangeControls() {
            const box = document.getElementById('sectorControlsContainer');
            // remove all three old classes
            _positions.forEach(c => box.classList.remove(c));
            // add the next
            box.classList.add(_positions[_posIndex]);
            // bump index
            _posIndex = (_posIndex + 1) % _positions.length;
        }


        function closeModal(id) { document.getElementById(id).style.display = 'none'; }

        function toggleTheme() {
            const current = document.body.classList.contains("dark") ? "dark" : "light";
            const next = current === "dark" ? "light" : "dark";
            document.body.classList.remove(current);
            document.body.classList.add(next);
            localStorage.setItem("theme", next);
        }

        function toggleHelp() {
            document.getElementById('controlsModal').style.display = 'block';
        }
        function toggleInfo() {
            document.getElementById('infoModal').style.display = 'block';
        }
        function toggleFeatures() {
            document.getElementById('featuresModal').style.display = 'block';
        }

        // Auto-apply saved theme on load
        (function applySavedTheme() {
            const saved = localStorage.getItem("theme");
            if (saved === "dark" || saved === "light") {
                document.body.classList.add(saved);
            } else {
                // fallback to system preference
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                document.body.classList.add(prefersDark ? 'dark' : 'light');
            }
        })();



        function drawHex(q, r, label) {
            const center = hexToPixel(q, r);
            const pts = [];
            for (let i = 0; i < 6; i++) {
                const ang = Math.PI / 180 * (60 * i);
                pts.push(`${center.x + hexRadius * Math.cos(ang)},${center.y + hexRadius * Math.sin(ang)}`);
            }

            const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            poly.setAttribute('points', pts.join(' '));
            poly.setAttribute('fill', sectorColors['']);
            poly.classList.add('hex');
            poly.addEventListener('click', e => {
                if (mode === 'hyperlane') {
                    if (e.shiftKey) {
                        deleteAllSegments(label);
                    } else if (e.altKey) {
                        unlinking = true;
                        selectHex(label);
                    } else {
                        selectHex(label);
                    }
                } else {
                    setSectorType(label, mode);
                }
            });
            poly.addEventListener('mouseenter', () => hoveredHexLabel = label);
            poly.addEventListener('mouseleave', () => hoveredHexLabel = null);
            svg.appendChild(poly);

            const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            txt.setAttribute('x', center.x);
            txt.setAttribute('y', center.y + 5);
            txt.setAttribute('text-anchor', 'middle');
            txt.textContent = label;
            svg.appendChild(txt);

            hexes[label] = {
                q, r, center,
                polygon: poly,
                type: '',
                overlays: [],
                baseType: '',
                effects: new Set(),
                matrix: Array.from({ length: 6 }, () => Array(6).fill(0))
            };

        }

        function setSectorType(label, selected) {
            const hex = hexes[label];
            if (!hex) return;

            const baseTypes = ['1 planet', '2 planet', '3 planet', 'legendary planet', 'empty', 'void', 'special', 'homesystem'];
            const effectTypes = ['nebula', 'supernova', 'rift', 'asteroid', 'homesystem']; // HS can be effect too

            // Remove previous overlays
            hex.overlays.forEach(el => svg.removeChild(el));
            hex.overlays = [];

            // Set base type or toggle effect
            if (baseTypes.includes(selected)) {
                hex.baseType = selected;

                // Reset effects if changing base (only if it's a base type change)
                hex.effects = new Set();
            } else if (effectTypes.includes(selected)) {
                if (!hex.effects) hex.effects = new Set();
                hex.effects.add(selected); // Add effect
            }

            // Apply base color
            const baseColor = sectorColors[hex.baseType] || '#eee';
            hex.polygon.setAttribute('fill', baseColor);

            // Re-add overlays for all effects
            if (hex.effects) {
                Array.from(hex.effects).forEach((effect, i) => {
                    const overlay = createOverlay(effect, hex.center, i);
                    if (overlay) {
                        svg.appendChild(overlay);
                        hex.overlays.push(overlay);
                    }
                });
            }
        }


        function createOverlay(type, center, index = 0) {
            const iconMap = {
                'nebula': '☁️',
                'supernova': '☀️',
                'asteroid': '🪨',
                'rift': '🕳️',
                'homesystem': '★'
            };

            const symbol = iconMap[type] || '?';
            const offset = effectIconPositions[index % effectIconPositions.length];
            const x = center.x + offset.dx;
            const y = center.y + offset.dy + 5; // slight vertical center adjustment

            const icon = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            icon.setAttribute('x', x);
            icon.setAttribute('y', y);
            icon.setAttribute('text-anchor', 'middle');
            icon.setAttribute('class', 'hex-overlay');
            icon.textContent = symbol;
            icon.classList.add('hex-overlay');

            return icon;
        }



        function generateRings(n) {
            const layout = [];
            layout.push({ q: 0, r: 0, label: '000' }); // center

            for (let ring = 1; ring <= n; ring++) {
                let q = 0, r = -ring;
                let counter = 1; // Reset for each ring

                for (let side = 0; side < 6; side++) {
                    for (let step = 0; step < ring; step++) {
                        const label = `${ring}${counter.toString().padStart(2, '0')}`;


                        if (fillCorners) {
                            const { col, row } = axialToOffset(q, r);
                            if (col < -9 || col > 9 || row < -9 || row > 9) {
                                q += ringDirections[side].q;
                                r += ringDirections[side].r;
                                counter++;
                                continue;
                            }
                        }

                        layout.push({ q, r, label });

                        counter++;
                        q += ringDirections[side].q;
                        r += ringDirections[side].r;
                    }
                }
            }

            return layout;
        }


        function axialToOffset(q, r) {
            const col = q;
            const row = r + Math.floor(q / 2); // flat-top offset
            return { col, row };
        }

        // draw map
        //generateRings(3).forEach(h => drawHex(h.q, h.r, h.label));

        function generateMap() {
            console.log("Console is working!");
            if (!confirm("Generating a new map will clear all data. Proceed?")) return;

            const inputRings = parseInt(document.getElementById('ringCount').value, 10);
            if (isNaN(inputRings) || inputRings < 1 || inputRings > 15) {
                alert("Please enter a ring count between 1 and 15.");
                return;
            }

            const ringsToDraw = fillCorners ? 14 : inputRings;

            while (svg.firstChild) svg.removeChild(svg.firstChild);

            Object.keys(hexes).forEach(key => delete hexes[key]);
            drawnSegments.length = 0;
            selectedPath.length = 0;

            generateRings(ringsToDraw).forEach(h => drawHex(h.q, h.r, h.label));
            drawSpecialHexes();

            console.log('Checking matrix for loop circles after deletion...');

            // Clear all lingering loopback circles first (safety net)
            svg.querySelectorAll('circle.link-line').forEach(c => svg.removeChild(c));
            autoscaleView();
        }

        function clearAllEffects(label) {
            const hex = hexes[label];
            if (!hex) return;

            // Remove overlay icons
            hex.overlays.forEach(el => svg.removeChild(el));
            hex.overlays = [];

            // Clear effects
            if (hex.effects) {
                hex.effects.clear();
            }

            // Clear baseType and reset color
            hex.baseType = '';
            hex.polygon.setAttribute('fill', sectorColors['']);

            resetHex(hoveredHexLabel);
        }




        function resetHex(label) {
            const hex = hexes[label];
            if (!hex) return;

            // Remove all segments from drawnSegments and SVG
            for (let i = drawnSegments.length - 1; i >= 0; i--) {
                const seg = drawnSegments[i];
                if (seg.dataset?.via === label) {
                    if (svg.contains(seg)) svg.removeChild(seg);
                    drawnSegments.splice(i, 1);
                }
            }

            //  Fallback: directly remove any stray SVG elements not in drawnSegments
            svg.querySelectorAll(`.link-line[data-via="${label}"]`).forEach(el => {
                if (svg.contains(el)) svg.removeChild(el);
            });
            //  Also remove all plain <circle> tags not picked up by dataset
            svg.querySelectorAll('circle.link-line').forEach(circle => {
                if (circle.dataset.via === label && svg.contains(circle)) {
                    svg.removeChild(circle);
                }
            });

            // Reset matrix
            if (hex.matrix) {
                for (let i = 0; i < 6; i++) {
                    for (let j = 0; j < 6; j++) {
                        hex.matrix[i][j] = 0;
                    }
                }
            }

            // Reset sector type and polygon fill
            hex.type = '';
            if (hex.polygon) {
                hex.polygon.setAttribute('fill', sectorColors['']);
                hex.polygon.classList.remove('selected');
            }

            console.log(` Hex ${label} fully reset.`);
        }



        function selectHex(label) {
            if (!linking) return;

            const hex = hexes[label];

            // Avoid duplicate selection
            const last = selectedPath[selectedPath.length - 1];

            if (!last || areNeighbors(last, label)) {
                selectedPath.push(label);
                hex.polygon.classList.add('selected');
            } else {
                console.warn(`Hex ${label} is not adjacent to ${last}.`);
            }


            //  LOOPBACK: A → B → A (draw loop in B)
            if (
                selectedPath.length === 3 &&
                selectedPath[0] === selectedPath[2] && // A → B → A
                selectedPath[0] !== selectedPath[1]
            ) {
                const from = hexes[selectedPath[0]];
                const via = hexes[selectedPath[1]];
                const entry = getDirIndex(via, from);

                if (entry >= 0 && via.matrix[entry][entry] === 0) {
                    // Line from edge of 'via' into its center — but stop at the circle's edge
                    const start = edgeMid(via.center, entry);
                    const cx = via.center.x;
                    const cy = via.center.y;
                    const radius = 15;

                    // Compute angle from start to center
                    const angleToCenter = Math.atan2(cy - start.y, cx - start.x);

                    // Stop the line at the edge of the circle
                    const endX = cx - Math.cos(angleToCenter) * radius;
                    const endY = cy - Math.sin(angleToCenter) * radius;

                    // Use a control point halfway along the curve
                    const mx = (start.x + endX) / 2;
                    const my = (start.y + endY) / 2;
                    const controlX = cx + (mx - cx) * 1;
                    const controlY = cy + (my - cy) * 1;

                    const loopPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    loopPath.setAttribute('d', `M${start.x},${start.y} Q${controlX},${controlY} ${endX},${endY}`);
                    loopPath.classList.add('link-line');
                    loopPath.dataset.via = selectedPath[1];
                    loopPath.dataset.entry = entry;
                    loopPath.dataset.exit = entry;
                    svg.appendChild(loopPath);
                    drawnSegments.push(loopPath);

                    // Circle in center of 'via'
                    const loopCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    loopCircle.setAttribute('cx', via.center.x);
                    loopCircle.setAttribute('cy', via.center.y);
                    loopCircle.setAttribute('r', 14);
                    loopCircle.setAttribute('stroke', 'blue');
                    loopCircle.setAttribute('stroke-width', 2);
                    loopCircle.setAttribute('fill', 'none');
                    loopCircle.classList.add('link-line');
                    svg.appendChild(loopCircle);
                    drawnSegments.push(loopCircle);

                    // Save in matrix
                    via.matrix[entry][entry] = 1;

                    // Connect all loopbacks internally
                    for (let i = 0; i < 6; i++) {
                        if (i !== entry && via.matrix[i][i] === 1) {
                            via.matrix[entry][i] = 1;
                            via.matrix[i][entry] = 1;
                        }
                    }
                }

                selectedPath.forEach(id => hexes[id].polygon.classList.remove('selected'));
                selectedPath = [];
                return;
            }

            // NORMAL LINK DRAWING (after 3 clicks)
            if (selectedPath.length >= 3) {
                const len = selectedPath.length;
                const from = hexes[selectedPath[len - 3]];
                const via = hexes[selectedPath[len - 2]];
                const to = hexes[selectedPath[len - 1]];
                const entry = getDirIndex(via, from);
                const exit = getDirIndex(via, to);

                if (unlinking) {
                    if (via.matrix[entry][exit] === 1) {
                        via.matrix[entry][exit] = 0;
                        const toRemove = drawnSegments.findIndex(seg =>
                            seg.dataset.via === selectedPath[len - 2] &&
                            +seg.dataset.entry === entry &&
                            +seg.dataset.exit === exit
                        );
                        if (toRemove >= 0) {
                            svg.removeChild(drawnSegments[toRemove]);
                            drawnSegments.splice(toRemove, 1);
                        }
                    }
                    selectedPath.forEach(id => hexes[id].polygon.classList.remove('selected'));
                    selectedPath = [];
                    unlinking = false;
                    return;
                }

                // Normal curve between entry and exit
                drawCurveLink(via, entry, exit, selectedPath[len - 2]);
                via.matrix[entry][exit] = 1;

                selectedPath.slice(0, -2).forEach(id => hexes[id].polygon.classList.remove('selected'));
                selectedPath = selectedPath.slice(-2);
            }
        }

        function areNeighbors(a, b) {
            const dq = hexes[b].q - hexes[a].q;
            const dr = hexes[b].r - hexes[a].r;
            return edgeDirections.some(d => d.q === dq && d.r === dr);
        }

        function drawLoopCircle(x, y, label) {
            // Remove any stale circles from DOM before drawing
            svg.querySelectorAll(`circle.link-line[data-via="${label}"]`).forEach(c => {
                console.warn("Pre-clearing old loop circle:", c);
                svg.removeChild(c);
            });

            // Also remove from drawnSegments
            drawnSegments = drawnSegments.filter(
                seg => !(seg.tagName === 'circle' && seg.dataset.via === label)
            );

            // Now draw fresh circle
            const loopCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            loopCircle.setAttribute('cx', x);
            loopCircle.setAttribute('cy', y);
            loopCircle.setAttribute('r', 15);
            loopCircle.setAttribute('stroke', 'blue');
            loopCircle.setAttribute('stroke-width', 2);
            loopCircle.setAttribute('fill', 'none');
            loopCircle.classList.add('link-line');
            loopCircle.dataset.via = label;

            svg.appendChild(loopCircle);
            drawnSegments.push(loopCircle);
        }

        function drawLoopArc(hex, entry, exit) {
            const start = edgeMid(hex.center, entry);
            const end = edgeMid(hex.center, exit);
            const mx = (start.x + end.x) / 2;
            const my = (start.y + end.y) / 2;
            const cx = hex.center.x + (mx - hex.center.x) * 1.3;
            const cy = hex.center.y + (my - hex.center.y) * 1.3;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M${start.x},${start.y} Q${cx},${cy} ${end.x},${end.y}`);
            path.classList.add('link-line');
            path.dataset.via = Object.keys(hexes).find(k => hexes[k] === hex);
            path.dataset.entry = entry;
            path.dataset.exit = exit;
            svg.appendChild(path);
            drawnSegments.push(path);
        }





        function edgeMid(center, side) {
            const a1 = Math.PI / 180 * (60 * side - 120);
            const a2 = Math.PI / 180 * (60 * (side + 1) - 120);
            const x1 = center.x + hexRadius * Math.cos(a1);
            const y1 = center.y + hexRadius * Math.sin(a1);
            const x2 = center.x + hexRadius * Math.cos(a2);
            const y2 = center.y + hexRadius * Math.sin(a2);
            return { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
        }

        function getDirIndex(via, other) {
            const dq = other.q - via.q;
            const dr = other.r - via.r;
            return edgeDirections.findIndex(d => d.q === dq && d.r === dr);
        }

        function deleteAllSegments(label) {
            const hex = hexes[label];

            // Remove all drawn segments related to this hex
            for (let i = drawnSegments.length - 1; i >= 0; i--) {
                const seg = drawnSegments[i];
                if (seg.dataset?.via === label) {
                    svg.removeChild(seg);
                    drawnSegments.splice(i, 1);
                }
            }

            // Force remove any circle elements in the DOM with matching data-via
            const lingeringCircles = svg.querySelectorAll(`circle.link-line[data-via="${label}"]`);
            lingeringCircles.forEach(circle => {
                svg.removeChild(circle);
            });

            // Ensure drawnSegments no longer tracks those circles
            drawnSegments = drawnSegments.filter(seg => {
                return !(seg.tagName === 'circle' && seg.dataset?.via === label);
            });

            // Wipe matrix
            if (hex.matrix) {
                for (let i = 0; i < 6; i++) {
                    for (let j = 0; j < 6; j++) {
                        hex.matrix[i][j] = 0;
                    }
                }
            }

            // As last resort: remove orphaned circle with no data-via but at same coordinates
            svg.querySelectorAll('circle.link-line').forEach(c => {
                const cx = parseFloat(c.getAttribute('cx'));
                const cy = parseFloat(c.getAttribute('cy'));
                const hex = hexes[label];
                if (!hex || !hex.center) return;

                if (Math.abs(cx - hex.center.x) < 0.1 && Math.abs(cy - hex.center.y) < 0.1) {
                    console.warn(`🧼 Force-removing stray circle at ${label}`);
                    svg.removeChild(c);
                }
            });

            console.log(` Deleted all segments and loopbacks for ${label}`);
        }


        function toggleCorners() {
            fillCorners = document.getElementById('cornerToggle').checked;
            generateMap(); // regenerate map with or without corners
        }

        function drawCornerHex(x, y, label) {
            const pts = [];
            for (let i = 0; i < 6; i++) {
                const ang = Math.PI / 180 * (60 * i);
                pts.push(
                    `${x + hexRadius * Math.cos(ang)},${y + hexRadius * Math.sin(ang)}`
                );
            }


            const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            poly.setAttribute('points', pts.join(' '));
            poly.setAttribute('fill', '#ddd');
            poly.classList.add('hex');
            svg.appendChild(poly);

            const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            txt.setAttribute('x', x);
            txt.setAttribute('y', y + 5);
            txt.setAttribute('text-anchor', 'middle');
            txt.textContent = label;
            svg.appendChild(txt);
        }

        function autoscaleView() {
            const allPoints = Object.values(hexes).map(h => h.center);
            if (allPoints.length === 0) return;

            const xs = allPoints.map(p => p.x);
            const ys = allPoints.map(p => p.y);
            const minX = Math.min(...xs) - hexRadius * 2;
            const maxX = Math.max(...xs) + hexRadius * 2;
            const minY = Math.min(...ys) - hexRadius * 2;
            const maxY = Math.max(...ys) + hexRadius * 2;

            const width = maxX - minX;
            const height = maxY - minY;

            svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
        }

        svg.addEventListener('contextmenu', e => {
            e.preventDefault();
            selectedPath.forEach(id => hexes[id].polygon.classList.remove('selected'));
            selectedPath = [];
            linking = true;
        });


        function applySectorTypesFromString(typeString) {
            const tokens = typeString.replace(/^\{|\}$/g, '').split(/\s+/).filter(Boolean);
            const ids = Object.keys(hexes).filter(id => /^\d{3}$/.test(id)).sort((a, b) => {
                const [ra, ia] = [parseInt(a[0]), parseInt(a.slice(1))];
                const [rb, ib] = [parseInt(b[0]), parseInt(b.slice(1))];
                return ra === rb ? ia - ib : ra - rb;
            });

            if (tokens.length !== ids.length) {
                console.warn("Type string does not match number of hexes.");
                return;
            }

            for (let i = 0; i < tokens.length; i++) {
                const code = tokens[i];
                const label = ids[i];
                const hex = hexes[label];
                if (!hex) continue;

                // Only update if never imported or not manually changed
                if (!originalHexIDs[label]) {
                    originalHexIDs[label] = code;
                } else if (originalHexIDs[label] !== code) {
                    // Skip overwriting edited tiles
                    continue;
                }

                const info = sectorIDLookup[code] || {};

                // Reset
                hex.baseType = "";
                hex.effects = new Set();
                hex.overlays?.forEach(el => svg.removeChild(el));
                hex.overlays = [];

                // Assign logic
                if (code === "-1") {
                    hex.baseType = "void";
                } else if (code === "hl") {
                    hex.baseType = "empty"; // placeholder for later
                } else if (info.legend) {
                    hex.baseType = "legendary planet";
                } else if (info["# Planets"]) {
                    const n = parseFloat(info["# Planets"]);
                    hex.baseType = n >= 3 ? "3 planet" : n >= 2 ? "2 planet" : "1 planet";
                } else if (info.special) {
                    hex.baseType = "special";
                    if (info.Nebula) hex.effects.add("nebula");
                    if (info.Gravity) hex.effects.add("rift");
                    if (info.Nova) hex.effects.add("supernova");
                    if (info.Asteroid) hex.effects.add("asteroid");
                } else {
                    hex.baseType = "empty";
                }

                if (info.Faction) {
                    hex.effects.add("homesystem");
                }
                setSectorType(label, hex.baseType);
                console.log("🏷️ baseType check for", label, "=>", hex.baseType);
                if (['1 planet', '2 planet', '3 planet', 'legendary planet'].includes(hex.baseType)) {
                    console.log("🏷️ baseType check for", label, "=>", hex.baseType);
                    const res = parseInt(info["eff resource"]) || 0;
                    const inf = parseInt(info["eff influence"]) || 0;
                    hex.effResource = res;
                    hex.effInfluence = inf;
                    displayResourceInfluence(label);
                }
            }
        }


        function parseSectorCSV(csvText) {
            const lines = csvText.trim().split(/\r?\n/);
            const headers = lines[0].split(',').map(h => h.trim());
            const data = {};

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                const row = {};
                headers.forEach((key, idx) => {
                    row[key] = values[idx] ?? '';
                });

                const id = row["ID"]?.trim().toUpperCase();
                if (id) {
                    data[id] = row;
                }
            }

            return data;
        }

        document.getElementById("idImportCSV").addEventListener("change", function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (event) {
                const csv = event.target.result;
                sectorIDLookup = parseSectorCSV(csv);
                alert("Sector ID lookup table loaded.");
            };
            reader.readAsText(file);
        });


        function exportData() {
            const out = [];

            for (const id in hexes) {
                const hex = hexes[id];
                if (!hex.matrix) continue;

                // Clone the matrix for local mutation (to avoid touching UI state)
                const matrix = hex.matrix.map(row => [...row]);

                // Mirror all existing connections to ensure symmetry
                for (let entry = 0; entry < 6; entry++) {
                    for (let exit = 0; exit < 6; exit++) {
                        if (matrix[entry][exit] === 1) {
                            const dir = edgeDirections[exit];
                            const neighborQ = hex.q + dir.q;
                            const neighborR = hex.r + dir.r;

                            const neighbor = Object.values(hexes).find(
                                h => h.q === neighborQ && h.r === neighborR && h.matrix
                            );

                            if (neighbor) {
                                const reverseEntry = edgeDirections.findIndex(d => d.q === -dir.q && d.r === -dir.r);
                                if (reverseEntry !== -1) {
                                    matrix[exit][entry] = 1;
                                }
                            }
                        }
                    }
                }

                // Flatten and export only if any 1s exist
                const flat = matrix.flat().join('');
                if (flat.includes('1')) {
                    out.push(`${id},${flat}`);
                }
            }

            document.getElementById('exportText').value = out.join("\n");
            document.getElementById('exportModal').style.display = 'block';
        }


        function exportSectorTypes() {
            const typeMap = {
                '1 planet': '0b',
                '2 planet': '0b',
                '3 planet': '0b',
                'legendary planet': '0b',
                'solar': '80',
                'empty': '46',
                'nebula': '42',
                'asteroid': '44',
                'rift': '33',
                'special': '0r',
                'homesystem': '0g',
                'void': '-1',
                'hyperlane': 'hl'
            };

            const sorted = Object.keys(hexes)
                .filter(id => /^\d{3}$/.test(id))
                .sort((a, b) => {
                    const [ra, ia] = [parseInt(a[0]), parseInt(a.slice(1))];
                    const [rb, ib] = [parseInt(b[0]), parseInt(b.slice(1))];
                    return ra === rb ? ia - ib : ra - rb;
                });

            const out = sorted.map((id, idx) => {
                const hex = hexes[id];
                if (!hex) return idx === 0 ? '{-1}' : '-1';

                const isHyperlane = hex.matrix?.flat().some(x => x === 1);
                let base = hex.baseType || '';
                let code = isHyperlane ? 'hl' : (typeMap[base] ?? '-1');

                return idx === 0 ? `{${code}}` : code;
            });

            document.getElementById('exportTypesText').value = out.join(" ");
            document.getElementById('exportTypesModal').style.display = 'block';
        }

        function importData() {
            const input = document.getElementById('importText').value.trim();
            const lines = input.split('\n');

            lines.forEach(line => {
                const [label, flatMatrix] = line.split(',');
                const hex = hexes[label];
                if (!hex || flatMatrix.length !== 36) return;

                const matrix = Array.from({ length: 6 }, () => Array(6).fill(0));

                for (let i = 0; i < 6; i++) {
                    for (let j = 0; j < 6; j++) {
                        matrix[i][j] = parseInt(flatMatrix[i * 6 + j], 10);
                    }
                }

                hex.matrix = matrix;

                // Draw all links
                for (let entry = 0; entry < 6; entry++) {
                    for (let exit = 0; exit < 6; exit++) {
                        if (matrix[entry][exit] === 1) {
                            if (entry === exit) {
                                drawLoopCircle(hex.center.x, hex.center.y, label);
                                drawLoopbackCurve(hex, entry);
                            } else {
                                drawCurveLink(hex, entry, exit, label);
                            }
                        }
                    }
                }
            });

            document.getElementById('importModal').style.display = 'none';
        }




        function drawLoopbackCurve(hex, entry) {
            const start = edgeMid(hex.center, entry);
            const cx = hex.center.x;
            const cy = hex.center.y;
            const radius = 14;

            const angle = Math.atan2(cy - start.y, cx - start.x);
            const endX = cx - Math.cos(angle) * radius;
            const endY = cy - Math.sin(angle) * radius;

            const mx = (start.x + endX) / 2;
            const my = (start.y + endY) / 2;
            const controlX = cx + (mx - cx);
            const controlY = cy + (my - cy);

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M${start.x},${start.y} Q${controlX},${controlY} ${endX},${endY}`);
            path.classList.add('link-line');
            path.dataset.via = Object.keys(hexes).find(k => hexes[k] === hex);
            path.dataset.entry = entry;
            path.dataset.exit = entry;

            svg.appendChild(path);
            drawnSegments.push(path);
        }

        function drawCurveLink(hex, entry, exit, label) {
            const start = edgeMid(hex.center, entry);
            const end = edgeMid(hex.center, exit);
            const mx = (start.x + end.x) / 2;
            const my = (start.y + end.y) / 2;
            const cx = hex.center.x + (mx - hex.center.x) * 0.25;
            const cy = hex.center.y + (my - hex.center.y) * 0.25;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M${start.x},${start.y} Q${cx},${cy} ${end.x},${end.y}`);
            path.classList.add('link-line');
            path.dataset.via = label;
            path.dataset.entry = entry;
            path.dataset.exit = exit;
            svg.appendChild(path);
            drawnSegments.push(path);
        }

        function exportHyperlaneTilePositions() {
            const idsWithHyperlanes = Object.entries(hexes)
                .filter(([id, hex]) => hex.matrix?.flat().some(x => x === 1))
                .map(([id]) => id)
                .sort((a, b) => {
                    const [ra, ia] = [parseInt(a[0]), parseInt(a.slice(1))];
                    const [rb, ib] = [parseInt(b[0]), parseInt(b.slice(1))];
                    return ra === rb ? ia - ib : ra - rb;
                });

            const output = `/map add_tile tile_name: hl position: ${idsWithHyperlanes.join(",")}`;

            document.getElementById("exportHyperlanePositionsText").value = output;
            document.getElementById("exportHyperlanePositionsModal").style.display = "block";
        }


        function setMode(m) {
            mode = m;
            selectedPath = [];
            Object.values(hexes).forEach(h => h.polygon?.classList.remove('selected'));

            // Update active button styles
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.toLowerCase().includes(m)) {
                    btn.classList.add('active');
                }
            });
        }

        function importSectorTypes() {
            console.warn("Running importSectorTypes");
            const input = document.getElementById('importTypesText').value.trim();
            const tokens = input.replace(/[{}]/g, '').split(/\s+/);

            const sortedIDs = Object.keys(hexes)
                .filter(id => /^\d{3}$/.test(id))
                .sort((a, b) => {
                    const [ra, ia] = [parseInt(a[0]), parseInt(a.slice(1))];
                    const [rb, ib] = [parseInt(b[0]), parseInt(b.slice(1))];
                    return ra === rb ? ia - ib : ra - rb;
                });

            sortedIDs.forEach((hexID, index) => {
                let code = tokens[index];
                if (!code) return;

                if (index === 0 && code.startsWith("{") && code.endsWith("}")) {
                    code = code.slice(1, -1);
                }

                code = code.trim().replace(/['"]/g, '').toUpperCase();

                const hex = hexes[hexID];
                if (!hex) return;

                hex.originalCode = code;

                if (code === "-1") {
                    setSectorType(hexID, 'void');
                    return;
                }

                if (code === "HL") {
                    return; // Hyperlane
                }

                const entry = sectorIDLookup?.[code];
                if (!entry) {
                    console.warn(`⚠ Unknown code "${code}" at hex ${hexID}`);
                    return;
                }

                const isLegendary = entry["Legend"]?.trim();
                const isHS = entry["Faction"]?.trim() === "1";
                //  const isSpecial = entry["Special"]?.trim();
                const isSpecial = !!entry["Special"]?.trim();
                const planetCount = parseFloat(entry["# Planets"]) || 0;

                // Base type logic
                if (isLegendary) {
                    setSectorType(hexID, "legendary planet");

                } else if (isHS) {
                    if (planetCount >= 3) setSectorType(hexID, "3 planet");
                    else if (planetCount >= 2) setSectorType(hexID, "2 planet");
                    else if (planetCount >= 1) setSectorType(hexID, "1 planet");
                    else setSectorType(hexID, "empty");
                    //  setSectorType(hexID, "homesystem");
                    console.log(`Hex ${hexID} → code ${code} → # Planets:`, entry["# Planets"]);
                } else if (planetCount == 3) {
                    setSectorType(hexID, "3 planet");
                    console.log(`Hex ${hexID} → code ${code} → # Planets3:`, entry["# Planets"]);
                } else if (planetCount == 2) {
                    setSectorType(hexID, "2 planet");
                    console.log(`Hex ${hexID} → code ${code} → # Planets2:`, entry["# Planets"]);
                } else if (planetCount == 1) {
                    setSectorType(hexID, "1 planet");
                    console.log(`Hex ${hexID} → code ${code} → # Planets1:`, entry["# Planets"]);
                } else if (isSpecial) {
                    setSectorType(hexID, "special");
                } else {
                    setSectorType(hexID, "empty");
                }

                // Effects
                const effects = [];
                if (entry["Nebula"]?.trim()) effects.push("nebula");
                if (entry["Gravity"]?.trim()) effects.push("rift");
                if (entry["Nova"]?.trim()) effects.push("supernova");
                if (entry["Asteroid"]?.trim()) effects.push("asteroid");
                if (entry["Faction"]?.trim()) effects.push("homesystem");
                //   if (isHS) effects.push("homesystem");

                effects.forEach(effect => setSectorType(hexID, effect));
            });

            document.getElementById('importTypesModal').style.display = 'none';
        }

        function displayResourceInfluence(label) {
            const hex = hexes[label];
            console.log(`Drawing values on ${label}: ${hex.effResource} / ${hex.effInfluence}`);
            console.log(`🧩 Drawing for ${label}`, hex.effResource, hex.effInfluence, hex.baseType);
            if (!hex) return;

            console.log(`Drawing values on ${label}: ${hex.effResource} / ${hex.effInfluence}`);
            console.log(`🧩 Drawing for ${label}`, hex.effResource, hex.effInfluence, hex.baseType);

            // Remove old
            if (hex.resourceText) svg.removeChild(hex.resourceText);
            if (hex.influenceText) svg.removeChild(hex.influenceText);

            const isPlanet = ['1 planet', '2 planet', '3 planet', 'legendary planet'].includes(hex.baseType);
            if (!isPlanet) return;

            const res = hex.effResource ?? 0;
            const inf = hex.effInfluence ?? 0;

            const resText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            resText.setAttribute('x', hex.center.x - 30);
            resText.setAttribute('y', hex.center.y - 5);
            resText.setAttribute('text-anchor', 'middle');
            resText.setAttribute('class', 'hex-overlay');
            resText.textContent = res;
            svg.appendChild(resText);
            hex.resourceText = resText;

            const infText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            infText.setAttribute('x', hex.center.x + 30);
            infText.setAttribute('y', hex.center.y - 5);
            infText.setAttribute('text-anchor', 'middle');
            infText.setAttribute('class', 'hex-overlay');
            infText.textContent = inf;
            svg.appendChild(infText);
            hex.influenceText = infText;
        }


        /*
        function highlightReachableDirectional(startLabel, maxDistance = 2) {
            const visited = new Set();
            const distanceMap = {};
        
            // Distance 0 is the sector itself
            const queue = [{ label: startLabel, entry: null, distance: 0 }];
        
            // Clear any previous highlights
            Object.values(hexes).forEach(h => h.polygon?.classList.remove('reach-1', 'reach-2'));
        
            while (queue.length > 0) {
                const { label, entry, distance } = queue.shift();
                const key = `${label}:${entry}`;
        
                if (visited.has(key) || distance > maxDistance) continue;
                visited.add(key);
        
                if (!distanceMap[label] || distance < distanceMap[label]) {
                    distanceMap[label] = distance;
                }
        
                const hex = hexes[label];
                if (!hex || !hex.matrix) continue;
        
                // If coming from outside (entry === null), explore all valid exits
                if (entry === null) {
                    for (let exit = 0; exit < 6; exit++) {
                        for (let entryDir = 0; entryDir < 6; entryDir++) {
                            if (hex.matrix[entryDir][exit] === 1) {
                                const neighbor = findNeighborHex(hex, exit);
                                if (!neighbor) continue;
        
                                const neighborLabel = getHexLabel(neighbor);
                                const newEntry = (exit + 3) % 6;
        
                                queue.push({
                                    label: neighborLabel,
                                    entry: newEntry,
                                    distance: distance + 1
                                });
                            }
                        }
                    }
                }
                // Otherwise: we're inside a hyperlane path
                else {
                    for (let exit = 0; exit < 6; exit++) {
                        if (hex.matrix[entry][exit] === 1 || (hex.matrix[entry][entry] === 1 && entry !== exit && hex.matrix[entry][exit] === 1)) {
                            const neighbor = findNeighborHex(hex, exit);
                            if (!neighbor) continue;
        
                            const neighborLabel = getHexLabel(neighbor);
                            const newEntry = (exit + 3) % 6;
        
                            queue.push({
                                label: neighborLabel,
                                entry: newEntry,
                                distance: distance + 1
                            });
                        }
                    }
                }
            }
        
            // Apply styling
            for (const [label, dist] of Object.entries(distanceMap)) {
                if (dist === 1) hexes[label].polygon.classList.add('reach-1');
                if (dist === 2) hexes[label].polygon.classList.add('reach-2');
            }
        }
        
        function findNeighborHex(hex, side) {
            const dir = edgeDirections[side];
            const nq = hex.q + dir.q;
            const nr = hex.r + dir.r;
            return Object.values(hexes).find(h => h.q === nq && h.r === nr);
        }
        
        function getHexLabel(hex) {
            return Object.keys(hexes).find(k => hexes[k] === hex);
        }
        */

        function drawSpecialHexes() {
            const allPoints = Object.values(hexes).map(h => h.center);
            if (allPoints.length === 0) return;

            const xs = allPoints.map(p => p.x);
            const ys = allPoints.map(p => p.y);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);

            const offset = hexRadius * 2;

            const corners = [
                { label: 'TL', x: minX - offset, y: minY - offset },
                { label: 'TR', x: maxX + offset, y: minY - offset },
                { label: 'BL', x: minX - offset, y: maxY + offset },
                { label: 'BR', x: maxX + offset, y: maxY + offset }
            ];

            for (const { label, x, y } of corners) {
                drawCornerHex(x, y, label);
                hexes[label] = {
                    q: null,
                    r: null,
                    center: { x, y },
                    polygon: null,
                    matrix: null,
                    type: 'corner'
                };
            }
        }



        let currentViewBox = [0, 0, 1000, 1000];
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        svg.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scaleFactor = 1.1;
            const [x, y, w, h] = currentViewBox;
            const mx = e.offsetX / svg.clientWidth;
            const my = e.offsetY / svg.clientHeight;
            const zoomIn = e.deltaY < 0;

            const dw = zoomIn ? w / scaleFactor : w * scaleFactor;
            const dh = zoomIn ? h / scaleFactor : h * scaleFactor;

            const newX = x + (w - dw) * mx;
            const newY = y + (h - dh) * my;

            currentViewBox = [newX, newY, dw, dh];
            svg.setAttribute('viewBox', currentViewBox.join(' '));
        });

        svg.addEventListener('mousedown', (e) => {
            if (e.button === 1) { // Middle mouse button
                e.preventDefault(); // Prevent browser autoscroll
                isPanning = true;
                panStart = { x: e.clientX, y: e.clientY };
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = (e.clientX - panStart.x) * currentViewBox[2] / svg.clientWidth;
            const dy = (e.clientY - panStart.y) * currentViewBox[3] / svg.clientHeight;

            currentViewBox[0] -= dx;
            currentViewBox[1] -= dy;
            panStart = { x: e.clientX, y: e.clientY };
            svg.setAttribute('viewBox', currentViewBox.join(' '));
        });

        window.addEventListener('keydown', e => {
            if (e.key.toLowerCase() === 'r' && e.shiftKey && hoveredHexLabel) {
                console.log(`🧼 Full clear on ${hoveredHexLabel}`);
                deleteAllSegments(hoveredHexLabel);
                clearAllEffects(hoveredHexLabel);
            }
        });
        /*
                window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'd' && e.shiftKey && hoveredHexLabel) {
                highlightReachableDirectional(hoveredHexLabel, 3);
            }
        });
        
        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'c' && e.shiftKey) {
                Object.values(hexes).forEach(h => h.polygon?.classList.remove('reachable'));
            }
        });
        */

        window.addEventListener('mouseup', () => {
            isPanning = false;
        });

        document.getElementById("idImportCSV").addEventListener("change", function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (event) {
                const csv = event.target.result;
                sectorIDLookup = parseSectorCSV(csv);

                // ✅ Debug log to verify the parsed structure
                console.log("Parsed first row:", Object.values(sectorIDLookup)[0]);

                alert("Sector ID lookup table loaded.");
            };
            reader.readAsText(file);
        });

        window.addEventListener("DOMContentLoaded", () => {
            fetch("sector_data.csv")
                .then(response => {
                    if (!response.ok) throw new Error("CSV load failed");
                    return response.text();
                })
                .then(csv => {
                    sectorIDLookup = parseSectorCSV(csv);
                    console.log("✅ Sector data loaded silently from CSV.");
                })
                .catch(err => {
                    console.warn("⚠️ Could not preload sector_data.csv:", err);
                });
        });

        generateMap();

    </script>



</body>

</html>